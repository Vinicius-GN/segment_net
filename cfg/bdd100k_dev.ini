[DIRS]

data_folder= /mnt/data/dataset/BDD100K
mapping_path = /mnt/workspace/segment_net/params/bdd100k.json
logs= /mnt/workspace/segment_net/logs

# not used
metadata_path = /mnt/workspace/segment_net/params/bdd100k.json

[MODE]

# [train, resume, test]
mode= train

[SPLITS]

# not used
train_seqs= /mnt/data/dataset/BDD100K/10K/
val_seqs= /mnt/data/dataset/BDD100K/10K/
test_sets= /mnt/data/dataset/BDD100K/10K/

[DATA]

# urban datasets:              [bdd100k, a2d2]
# off-road datasets:           [rellis3d, rudg]
# urban and off-road datasets: [goose]
dataset = bdd100k

#number of samples (-1, all)
num_samples=200
num_samples_plot = 4
batch_size = 1

[TRAIN]

epochs = 100
patience = 2
steps_minibatch_optimizer = 1

[CHECKPOINT]

steps_train = 10
save_best = true
save_last = true
steps_plot_train = 500

[MODEL]

learning_rate = 0.0001
weight_decay = 0.00001
dropout = 0.2
grad_norm = 5.0

#[batch_norm, group_norm]
norm_fn = group_norm

[BACKBONE]

# convolution: [resnet18, mobilenetv3, efficientnetb0, deeplabv3_mobilenetv3]
# transformer: [mobilevit, deit3_small, efficientformer, levit, segformerb0, pitxs, sam2_hiera, tinyvit, fastvit, maxxvitv2]
# hybrid: [convnextv2]
type = segformerb0

fpn_out_channels= 32

#[sum, concat, weighted_sum, max_pool]
aggregate=sum

# resnet18 -> 4 weights
# mobilenetv3 -> 5 weights
# deeplabv3_mobilenetv3 -> 5 weights
# efficientnetb0 -> 4 weights
# deit3_small -> 5 weights
# mobilevit -> 6 weights
# efficientformer -> 4 weights
# segformerb0 -> 4 weights
# pitxs -> 4 weights
# levit -> 4 weights
layer_weights=[2., 1., 1., 2., 1., 1.]

dropout = 0.2

[ATTENTION]

#[none, spatial, query, class_channel, se_channel]
type = query

reduction_rate = 4

dropout = 0.05

[HEAD]

dropout=0.2

#[se_conv_interp, depthwise_nn, transformer]
type=transformer

num_blocks = 1

# optimize classifier for low latency:
# true: conv + interpolation
# false: interpolation + conv
opt_latency = true

num_head_transformer = 2

[LOSS]

# dice, focal_dice, 
# cross_entropy, focal_cross_entropy, 
# lovasz_softmax, boundary_dice,
# hausdorff_dt_dice
type = boundary_dice

alpha = 0.25
gamma = 2.0

# "Unknown" :  0,
# "Dirt"    :  1,
# "Grass"   :  2,
# "Tree"    :  3,
# "Pole"    :  4,
# "Water"   :  5,
# "Sky"     :  6,
# "Vehicle" :  7,
# "Object"  :  8,
# "Asphalt" :  9,
# "Building": 10,
# "Log"     : 11,
# "Person"  : 12,
# "Fence"   : 13,
# "Bush"    : 14,
# "Concrete": 15,
# "Barrier" : 16,
# "Puddle"  : 17,
# "Mud"     : 18,
# "Rubble"  : 19 

# Class weights for the image to handle imbalanced distribution
class_weights = [1.0, 1.0, 1.0, 1.0, 1.0, 
                 1.0, 1.0, 1.0, 1.0, 1.0, 
                 1.0, 1.0, 1.0, 1.0, 1.0, 
                 1.0, 1.0, 1.0, 1.0, 1.0]

# value to multiply the loss by
loss_scale = 10.0

[IMAGE]

num_classes = 20

#[width, height] = [960, 604]
#[width, height] = [320, 201]
image_size = [160, 100]

resize = true


