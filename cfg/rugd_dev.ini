[DIRS]

data_folder= /mnt/data/dataset/RUGD
mapping_path = /mnt/workspace/segment_net/params/rugd.json
logs= /mnt/workspace/segment_net/logs

#not used
metadata_path = /mnt/workspace/segment_net/params/rugd.json

[MODE]

#[train, resume, test]
mode= train

[SPLITS]

train_seqs= ["park-2", "trail", "trail-3", "trail-4", 
             "trail-6", "trail-9", "trail-10", 
             "trail-11", "trail-12", "trail-14", 
             "trail-15", "village"]

val_seqs= ["park-8", "trail-5"]

test_sets= ["creek", "park-1", "trail-7", "trail-13"]

[DATA]

# urban datasets:              [bdd100k, a2d2]
# off-road datasets:           [rellis3d, rudg]
# urban and off-road datasets: [goose]
dataset = rugd

#number of samples (-1, all)
num_samples=-1
num_samples_plot = 4
batch_size = 1

[TRAIN]

epochs = 100
patience = 2
steps_minibatch_optimizer = 1

[CHECKPOINT]

steps_train = 10
save_best = true
save_last = true
steps_plot_train = 500

[MODEL]

learning_rate = 0.0001
weight_decay = 0.00001
dropout = 0.2
grad_norm = 5.0

#[batch_norm, group_norm]
norm_fn = group_norm

[BACKBONE]

# convolution: [resnet18, mobilenetv3, efficientnetb0, deeplabv3_mobilenetv3, convnextv2]
# transformer: [deit3_small, sam2_hiera, pitxs, segformerb0, levit, tinyvit, fastvit]
# hybrid: [mobilevit, efficientformer, maxxvitv2, edgenext]
type = segformerb0

fpn_out_channels= 128

#[sum, concat, weighted_sum, max_pool]
aggregate=max_pool

# resnet18 -> 4 weights
# mobilenetv3 -> 5 weights
# deeplabv3_mobilenetv3 -> 5 weights
# efficientnetb0 -> 4 weights
# deit3_small -> 5 weights
# mobilevit -> 6 weights
# efficientformer -> 4 weights
# segformerb0 -> 4 weights
# pitxs -> 4 weights
# levit -> 4 weights
layer_weights=[2., 1., 1., 2., 1., 1.]

dropout = 0.2

[ATTENTION]

#[none, spatial, query, class_channel, se_channel]
type = query

reduction_rate = 4

dropout = 0.05

[HEAD]

dropout=0.2

#[se_conv_interp, depthwise_nn, transformer]
type=depthwise_nn

num_blocks = 4

# optimize classifier for low latency:
# true: conv + interpolation
# false: interpolation + conv
opt_latency = true

num_head_transformer = 2

[LOSS]

# dice, focal_dice, 
# cross_entropy, focal_cross_entropy, 
# lovasz_softmax, boundary_dice,
# hausdorff_dt_dice
type = boundary_dice

alpha = 0.25
gamma = 2.0

# "Unknown":         0,
# "Dirt":            1,
# "Sand":            2,
# "Grass":           3,
# "Tree":            4,
# "Pole":            5,
# "Water":           6,
# "Sky":             7,
# "Vehicle":         8,
# "Generic object":  9,
# "Asphalt":        10,
# "Gravel":         11,
# "Building":       12,
# "Mulch":          13,
# "Rock-bed":       14,
# "Log":            15,
# "Bicycle":        16,
# "Person":         17,
# "Fence":          18,
# "Bush":           19,
# "Sign":           20,
# "Rock":           21,
# "Bridge":         22,
# "Concrete":       23,
# "Picnic-table":   24

# Class weights for the image to handle imbalanced distribution
class_weights = [1.0, 1.0, 1.0, 1.0, 1.0, 
                 1.0, 1.0, 1.0, 1.0, 1.0, 
                 1.0, 1.0, 1.0, 1.0, 1.0, 
                 1.0, 1.0, 1.0, 1.0, 1.0,
                 1.0, 1.0, 1.0, 1.0, 1.0]

# value to multiply the loss by
loss_scale = 10.0

[IMAGE]

num_classes = 25

#[width, height] = [960, 604]
image_size = [320, 201]

resize = true


